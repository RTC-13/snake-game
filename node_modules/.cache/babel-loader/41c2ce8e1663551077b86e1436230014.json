{"ast":null,"code":"import { Point } from \"./Point\";\n\n/**\r\n * Enum representing the direction directions\r\n * @enum {number}\r\n */\nvar Direction;\n/**\r\n * Class representing a Snake.\r\n */\n\n(function (Direction) {\n  Direction[Direction[\"Up\"] = 1] = \"Up\";\n  Direction[Direction[\"Down\"] = 2] = \"Down\";\n  Direction[Direction[\"Left\"] = 3] = \"Left\";\n  Direction[Direction[\"Right\"] = 4] = \"Right\";\n})(Direction || (Direction = {}));\n\nclass Snake {\n  /**\r\n   * Create a snake\r\n   * @param {string} color of the snake\r\n   * @param {Point} startPosition - Initial position of the snake's head.\r\n   * @param {number} size - Length of the snake.\r\n   */\n  constructor(color, startPosition, size) {\n    this.currentParts = void 0;\n    this.currentDirection = void 0;\n    this.snakeColor = void 0;\n    this.isCurrentlyActive = void 0;\n    this.snakeColor = color;\n    this.currentParts = [startPosition];\n\n    for (let i = 1; i < size; i++) {\n      const newX = startPosition.x + i;\n      const newY = startPosition.y;\n      this.currentParts.push(new Point(newX, newY));\n    }\n\n    this.currentDirection = Direction.Right;\n    this.isCurrentlyActive = true;\n  }\n  /**\r\n   * Access the color of the snake\r\n   * @returns {string} color\r\n   */\n\n\n  get color() {\n    return this.snakeColor;\n  }\n  /**\r\n   * Moves the snake forward the number of steps given.\r\n   * @param {number} steps - The number of steps to move the snake.\r\n   */\n\n\n  move(steps) {\n    const head = this.currentParts[0];\n    let newHead = null;\n\n    if (this.currentDirection === Direction.Left) {\n      newHead = new Point(head.x - steps, head.y);\n    } else if (this.currentDirection === Direction.Right) {\n      newHead = new Point(head.x + steps, head.y);\n    } else if (this.currentDirection === Direction.Up) {\n      newHead = new Point(head.x, head.y - steps);\n    } else if (this.currentDirection === Direction.Down) {\n      newHead = new Point(head.x, head.y + steps);\n    }\n\n    if (newHead !== null) {\n      this.currentParts.unshift(newHead);\n      this.currentParts.pop();\n    }\n  }\n  /**\r\n   * Turns the snake to the left\r\n   */\n\n\n  turnLeft() {\n    if (this.currentDirection === Direction.Left) {\n      this.currentDirection = Direction.Down;\n    } else if (this.currentDirection === Direction.Up) {\n      this.currentDirection = Direction.Left;\n    } else if (this.currentDirection === Direction.Right) {\n      this.currentDirection = Direction.Up;\n    } else if (this.currentDirection === Direction.Down) {\n      this.currentDirection = Direction.Right;\n    }\n  }\n  /**\r\n   * Turns the snake to the right\r\n   */\n\n\n  turnRight() {\n    if (this.currentDirection === Direction.Left) {\n      this.currentDirection = Direction.Up;\n    } else if (this.currentDirection === Direction.Up) {\n      this.currentDirection = Direction.Right;\n    } else if (this.currentDirection === Direction.Right) {\n      this.currentDirection = Direction.Down;\n    } else if (this.currentDirection === Direction.Down) {\n      this.currentDirection = Direction.Left;\n    }\n  }\n  /**\r\n   * Returns the current position of the Snake.\r\n   * @returns {Point} coordinates\r\n   */\n\n\n  get position() {\n    return this.currentParts[0];\n  }\n  /**\r\n   * Returns true if the head of this snake collides with the head or body of the given snake.\r\n   * @param {Collidable} other - Actor to check collision with.\r\n   * @returns {boolean} - True if collision occurs, false otherwise.\r\n   */\n\n\n  didCollide(other) {\n    if (other.type !== \"snake\") {\n      const head = this.position;\n      return other.position.equals(head);\n    } else {\n      const otherParts = other.parts().slice(1);\n      const head = this.position;\n      return otherParts.some(part => part.equals(head));\n    }\n  }\n  /**\r\n   * Returns true if the Snake is currently active.\r\n   * @returns {boolean} - True if the Snake is active, false otherwise.\r\n   */\n\n\n  get isActive() {\n    return this.isCurrentlyActive;\n  }\n  /**\r\n   * Returns the type of the Snake.\r\n   * @returns {string} - The type of the Snake.\r\n   */\n\n\n  get type() {\n    return \"snake\";\n  }\n  /**\r\n   * Adds one new Point to the snake's parts array.\r\n   * The new part is added one coordinate to the left of, right of, above, or below the end of its tail,\r\n   * depending on its direction.\r\n   */\n\n\n  grow() {\n    const tail = this.currentParts[this.currentParts.length - 1];\n    let newPart;\n\n    if (this.currentDirection === Direction.Left) {\n      newPart = new Point(tail.x + 1, tail.y);\n    } else if (this.currentDirection === Direction.Right) {\n      newPart = new Point(tail.x - 1, tail.y);\n    } else if (this.currentDirection === Direction.Up) {\n      newPart = new Point(tail.x, tail.y + 1);\n    } else if (this.currentDirection === Direction.Down) {\n      newPart = new Point(tail.x, tail.y - 1);\n    }\n\n    this.currentParts.push(newPart);\n  }\n  /**\r\n   * Method to set the Snake as inactive.\r\n   */\n\n\n  die() {\n    this.isCurrentlyActive = false;\n  }\n  /**\r\n   * Returns the direction of the snake.\r\n   * @returns {Direction} - Current direction of the snake.\r\n   */\n\n\n  get direction() {\n    return this.currentDirection;\n  }\n  /**\r\n   * Update method for the Snake.\r\n   * Calls the move method.\r\n   */\n\n\n  update() {\n    this.move(1);\n  }\n  /**\r\n   * Returns all parts of the snake.\r\n   * @returns {Point[]} - Array of points representing all parts of the snake.\r\n   */\n\n\n  parts() {\n    return this.currentParts;\n  }\n  /**\r\n   * String representation of the Snake class.\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    return this.snakeColor + \" is at the position \" + this.position;\n  }\n\n}\n\nexport { Snake, Direction };","map":{"version":3,"sources":["/Users/roberttineo/Desktop/snake-game/src/Snake.ts"],"names":["Point","Direction","Snake","constructor","color","startPosition","size","currentParts","currentDirection","snakeColor","isCurrentlyActive","i","newX","x","newY","y","push","Right","move","steps","head","newHead","Left","Up","Down","unshift","pop","turnLeft","turnRight","position","didCollide","other","type","equals","otherParts","parts","slice","some","part","isActive","grow","tail","length","newPart","die","direction","update","toString"],"mappings":"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","sourcesContent":["import { Point } from \"./Point\";\r\nimport ICollidable from \"./IColliadable\";\r\nimport IActor from \"./IActor\";\r\n\r\n/**\r\n * Enum representing the direction directions\r\n * @enum {number}\r\n */\r\nenum Direction {\r\n  Up = 1,\r\n  Down,\r\n  Left,\r\n  Right,\r\n}\r\n\r\n/**\r\n * Class representing a Snake.\r\n */\r\nclass Snake implements ICollidable {\r\n  private currentParts: Point[];\r\n  private currentDirection: number;\r\n  private snakeColor: string;\r\n  private isCurrentlyActive: boolean;\r\n\r\n  /**\r\n   * Create a snake\r\n   * @param {string} color of the snake\r\n   * @param {Point} startPosition - Initial position of the snake's head.\r\n   * @param {number} size - Length of the snake.\r\n   */\r\n  constructor(color: string, startPosition: Point, size: number) {\r\n    this.snakeColor = color;\r\n    this.currentParts = [startPosition];\r\n    for (let i = 1; i < size; i++) {\r\n      const newX = startPosition.x + i;\r\n      const newY = startPosition.y;\r\n      this.currentParts.push(new Point(newX, newY));\r\n    }\r\n    this.currentDirection = Direction.Right;\r\n    this.isCurrentlyActive = true;\r\n  }\r\n\r\n  /**\r\n   * Access the color of the snake\r\n   * @returns {string} color\r\n   */\r\n  public get color(): string {\r\n    return this.snakeColor;\r\n  }\r\n\r\n  /**\r\n   * Moves the snake forward the number of steps given.\r\n   * @param {number} steps - The number of steps to move the snake.\r\n   */\r\n  public move(steps: number) {\r\n    const head = this.currentParts[0];\r\n    let newHead: Point | null = null;\r\n    if (this.currentDirection === Direction.Left) {\r\n      newHead = new Point(head.x - steps, head.y);\r\n    } else if (this.currentDirection === Direction.Right) {\r\n      newHead = new Point(head.x + steps, head.y);\r\n    } else if (this.currentDirection === Direction.Up) {\r\n      newHead = new Point(head.x, head.y - steps);\r\n    } else if (this.currentDirection === Direction.Down) {\r\n      newHead = new Point(head.x, head.y + steps);\r\n    }\r\n    if (newHead !== null) {\r\n      this.currentParts.unshift(newHead);\r\n      this.currentParts.pop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turns the snake to the left\r\n   */\r\n  public turnLeft(): void {\r\n    if (this.currentDirection === Direction.Left) {\r\n      this.currentDirection = Direction.Down;\r\n    } else if (this.currentDirection === Direction.Up) {\r\n      this.currentDirection = Direction.Left;\r\n    } else if (this.currentDirection === Direction.Right) {\r\n      this.currentDirection = Direction.Up;\r\n    } else if (this.currentDirection === Direction.Down) {\r\n      this.currentDirection = Direction.Right;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turns the snake to the right\r\n   */\r\n  public turnRight(): void {\r\n    if (this.currentDirection === Direction.Left) {\r\n      this.currentDirection = Direction.Up;\r\n    } else if (this.currentDirection === Direction.Up) {\r\n      this.currentDirection = Direction.Right;\r\n    } else if (this.currentDirection === Direction.Right) {\r\n      this.currentDirection = Direction.Down;\r\n    } else if (this.currentDirection === Direction.Down) {\r\n      this.currentDirection = Direction.Left;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the current position of the Snake.\r\n   * @returns {Point} coordinates\r\n   */\r\n  public get position(): Point {\r\n    return this.currentParts[0];\r\n  }\r\n\r\n  /**\r\n   * Returns true if the head of this snake collides with the head or body of the given snake.\r\n   * @param {Collidable} other - Actor to check collision with.\r\n   * @returns {boolean} - True if collision occurs, false otherwise.\r\n   */\r\n  public didCollide(other: IActor): boolean {\r\n    if (other.type !== \"snake\") {\r\n      const head = this.position;\r\n      return other.position.equals(head);\r\n    } else {\r\n      const otherParts = other.parts().slice(1);\r\n      const head = this.position;\r\n      return otherParts.some((part) => part.equals(head));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the Snake is currently active.\r\n   * @returns {boolean} - True if the Snake is active, false otherwise.\r\n   */\r\n  public get isActive(): boolean {\r\n    return this.isCurrentlyActive;\r\n  }\r\n\r\n  /**\r\n   * Returns the type of the Snake.\r\n   * @returns {string} - The type of the Snake.\r\n   */\r\n  public get type(): string {\r\n    return \"snake\";\r\n  }\r\n\r\n  /**\r\n   * Adds one new Point to the snake's parts array.\r\n   * The new part is added one coordinate to the left of, right of, above, or below the end of its tail,\r\n   * depending on its direction.\r\n   */\r\n  public grow(): void {\r\n    const tail = this.currentParts[this.currentParts.length - 1];\r\n    let newPart: Point;\r\n    if (this.currentDirection === Direction.Left) {\r\n      newPart = new Point(tail.x + 1, tail.y);\r\n    } else if (this.currentDirection === Direction.Right) {\r\n      newPart = new Point(tail.x - 1, tail.y);\r\n    } else if (this.currentDirection === Direction.Up) {\r\n      newPart = new Point(tail.x, tail.y + 1);\r\n    } else if (this.currentDirection === Direction.Down) {\r\n      newPart = new Point(tail.x, tail.y - 1);\r\n    }\r\n    this.currentParts.push(newPart);\r\n  }\r\n\r\n  /**\r\n   * Method to set the Snake as inactive.\r\n   */\r\n  public die(): void {\r\n    this.isCurrentlyActive = false;\r\n  }\r\n\r\n  /**\r\n   * Returns the direction of the snake.\r\n   * @returns {Direction} - Current direction of the snake.\r\n   */\r\n  public get direction(): Direction {\r\n    return this.currentDirection;\r\n  }\r\n  /**\r\n   * Update method for the Snake.\r\n   * Calls the move method.\r\n   */\r\n  public update(): void {\r\n    this.move(1);\r\n  }\r\n\r\n  /**\r\n   * Returns all parts of the snake.\r\n   * @returns {Point[]} - Array of points representing all parts of the snake.\r\n   */\r\n  public parts(): Point[] {\r\n    return this.currentParts;\r\n  }\r\n\r\n  /**\r\n   * String representation of the Snake class.\r\n   * @returns {string}\r\n   */\r\n  toString(): string {\r\n    return this.snakeColor + \" is at the position \" + this.position;\r\n  }\r\n}\r\n\r\nexport { Snake, Direction };\r\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"// import display from \"./display\";\n// place your code on line 5 above the export statement below\nimport { Point } from \"./Point\";\n/**\r\n * Enum representing the direction directions\r\n * @enum {number}\r\n */\n\nvar Direction;\n/**\r\n * Class representing a Snake.\r\n */\n\n(function (Direction) {\n  Direction[Direction[\"Up\"] = 1] = \"Up\";\n  Direction[Direction[\"Down\"] = 2] = \"Down\";\n  Direction[Direction[\"Left\"] = 3] = \"Left\";\n  Direction[Direction[\"Right\"] = 4] = \"Right\";\n})(Direction || (Direction = {}));\n\nclass Snake {\n  /**\r\n   * Create a snake\r\n   * @param {string} color of the snake\r\n   * @param {Point} startPosition - Initial position of the snake's head.\r\n   * @param {number} size - Length of the snake.\r\n   */\n  constructor(color, startPosition, size) {\n    this.currentParts = void 0;\n    this.currentDirection = void 0;\n    this.snakeColor = void 0;\n    this.snakeColor = color;\n    this.currentParts = [startPosition];\n\n    for (let i = 1; i < size; i++) {\n      const newX = startPosition.x + i;\n      const newY = startPosition.y;\n      this.currentParts.push(new Point(newX, newY));\n    }\n\n    this.currentDirection = Direction.Right;\n  }\n  /**\r\n   * Access the color of the snake\r\n   * @returns {string} color\r\n   */\n\n\n  get color() {\n    return this.snakeColor;\n  }\n  /**\r\n   * Moves the snake forward the number of steps given.\r\n   * @param {number} steps - The number of steps to move the snake.\r\n   */\n\n\n  move(steps) {\n    const head = this.currentParts[0];\n    let newHead = null;\n\n    if (this.currentDirection === Direction.Left) {\n      newHead = new Point(head.x - steps, head.y);\n    } else if (this.currentDirection === Direction.Right) {\n      newHead = new Point(head.x + steps, head.y);\n    } else if (this.currentDirection === Direction.Up) {\n      newHead = new Point(head.x, head.y - steps);\n    } else if (this.currentDirection === Direction.Down) {\n      newHead = new Point(head.x, head.y + steps);\n    }\n\n    if (newHead !== null) {\n      this.currentParts.unshift(newHead);\n      this.currentParts.pop();\n    }\n  }\n  /**\r\n   * Turns the snake to the left\r\n   */\n\n\n  turnLeft() {\n    if (this.currentDirection === Direction.Left) {\n      this.currentDirection = Direction.Down;\n    } else if (this.currentDirection === Direction.Up) {\n      this.currentDirection = Direction.Left;\n    } else if (this.currentDirection === Direction.Right) {\n      this.currentDirection = Direction.Up;\n    } else if (this.currentDirection === Direction.Down) {\n      this.currentDirection = Direction.Right;\n    }\n  }\n  /**\r\n   * Turns the snake to the right\r\n   */\n\n\n  turnRight() {\n    if (this.currentDirection === Direction.Left) {\n      this.currentDirection = Direction.Up;\n    } else if (this.currentDirection === Direction.Up) {\n      this.currentDirection = Direction.Right;\n    } else if (this.currentDirection === Direction.Right) {\n      this.currentDirection = Direction.Down;\n    } else if (this.currentDirection === Direction.Down) {\n      this.currentDirection = Direction.Left;\n    }\n  }\n  /**\r\n   * Returns the current position of the Snake.\r\n   * @returns {Point} coordinates\r\n   */\n\n\n  get position() {\n    return this.currentParts[0];\n  }\n  /**\r\n   * Returns true if the head of this snake collides with the head or body of the given snake.\r\n   * @param {Snake} s - Snake to check collision with.\r\n   * @returns {boolean} - True if collision occurs, false otherwise.\r\n   */\n\n\n  didCollide(s) {\n    const head = this.position;\n    const otherParts = s.parts().slice(1);\n    return otherParts.some(part => part.equals(head));\n  }\n  /**\r\n   * Returs the direction of the snake.\r\n   */\n\n\n  get direction() {\n    return this.currentDirection;\n  }\n  /**\r\n   * Returns all parts of the snake.\r\n   * @returns {Point[]} - Array of points representing all parts of the snake.\r\n   */\n\n\n  parts() {\n    return this.currentParts;\n  }\n  /**\r\n   * String representation of the Snake class.\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    return this.snakeColor + \" is at the position \" + this.position;\n  }\n\n}\n\nexport { Snake, Direction };","map":{"version":3,"sources":["/Users/roberttineo/Desktop/snake-game/src/Snake.ts"],"names":["Point","Direction","Snake","constructor","color","startPosition","size","currentParts","currentDirection","snakeColor","i","newX","x","newY","y","push","Right","move","steps","head","newHead","Left","Up","Down","unshift","pop","turnLeft","turnRight","position","didCollide","s","otherParts","parts","slice","some","part","equals","direction","toString"],"mappings":"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","sourcesContent":["// import display from \"./display\";\r\n\r\n// place your code on line 5 above the export statement below\r\nimport { Point } from \"./Point\";\r\n\r\n/**\r\n * Enum representing the direction directions\r\n * @enum {number}\r\n */\r\nenum Direction {\r\n  Up = 1,\r\n  Down,\r\n  Left,\r\n  Right,\r\n}\r\n\r\n/**\r\n * Class representing a Snake.\r\n */\r\nclass Snake {\r\n  private currentParts: Point[];\r\n  private currentDirection: number;\r\n  private snakeColor: string;\r\n\r\n  /**\r\n   * Create a snake\r\n   * @param {string} color of the snake\r\n   * @param {Point} startPosition - Initial position of the snake's head.\r\n   * @param {number} size - Length of the snake.\r\n   */\r\n  constructor(color: string, startPosition: Point, size: number) {\r\n    this.snakeColor = color;\r\n    this.currentParts = [startPosition];\r\n    for (let i = 1; i < size; i++) {\r\n      const newX = startPosition.x + i;\r\n      const newY = startPosition.y;\r\n      this.currentParts.push(new Point(newX, newY));\r\n    }\r\n    this.currentDirection = Direction.Right;\r\n  }\r\n\r\n  /**\r\n   * Access the color of the snake\r\n   * @returns {string} color\r\n   */\r\n  public get color(): string {\r\n    return this.snakeColor;\r\n  }\r\n\r\n  /**\r\n   * Moves the snake forward the number of steps given.\r\n   * @param {number} steps - The number of steps to move the snake.\r\n   */\r\n  public move(steps: number) {\r\n    const head = this.currentParts[0];\r\n    let newHead: Point | null = null;\r\n    if (this.currentDirection === Direction.Left) {\r\n      newHead = new Point(head.x - steps, head.y);\r\n    } else if (this.currentDirection === Direction.Right) {\r\n      newHead = new Point(head.x + steps, head.y);\r\n    } else if (this.currentDirection === Direction.Up) {\r\n      newHead = new Point(head.x, head.y - steps);\r\n    } else if (this.currentDirection === Direction.Down) {\r\n      newHead = new Point(head.x, head.y + steps);\r\n    }\r\n    if (newHead !== null) {\r\n      this.currentParts.unshift(newHead);\r\n      this.currentParts.pop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turns the snake to the left\r\n   */\r\n  public turnLeft(): void {\r\n    if (this.currentDirection === Direction.Left) {\r\n      this.currentDirection = Direction.Down;\r\n    } else if (this.currentDirection === Direction.Up) {\r\n      this.currentDirection = Direction.Left;\r\n    } else if (this.currentDirection === Direction.Right) {\r\n      this.currentDirection = Direction.Up;\r\n    } else if (this.currentDirection === Direction.Down) {\r\n      this.currentDirection = Direction.Right;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turns the snake to the right\r\n   */\r\n  public turnRight(): void {\r\n    if (this.currentDirection === Direction.Left) {\r\n      this.currentDirection = Direction.Up;\r\n    } else if (this.currentDirection === Direction.Up) {\r\n      this.currentDirection = Direction.Right;\r\n    } else if (this.currentDirection === Direction.Right) {\r\n      this.currentDirection = Direction.Down;\r\n    } else if (this.currentDirection === Direction.Down) {\r\n      this.currentDirection = Direction.Left;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the current position of the Snake.\r\n   * @returns {Point} coordinates\r\n   */\r\n  public get position(): Point {\r\n    return this.currentParts[0];\r\n  }\r\n\r\n  /**\r\n   * Returns true if the head of this snake collides with the head or body of the given snake.\r\n   * @param {Snake} s - Snake to check collision with.\r\n   * @returns {boolean} - True if collision occurs, false otherwise.\r\n   */\r\n  public didCollide(s: Snake): boolean {\r\n    const head = this.position;\r\n    const otherParts = s.parts().slice(1);\r\n    return otherParts.some((part) => part.equals(head));\r\n  }\r\n  /**\r\n   * Returs the direction of the snake.\r\n   */\r\n  public get direction() {\r\n    return this.currentDirection;\r\n  }\r\n  /**\r\n   * Returns all parts of the snake.\r\n   * @returns {Point[]} - Array of points representing all parts of the snake.\r\n   */\r\n  public parts(): Point[] {\r\n    return this.currentParts;\r\n  }\r\n\r\n  /**\r\n   * String representation of the Snake class.\r\n   * @returns {string}\r\n   */\r\n  toString(): string {\r\n    return this.snakeColor + \" is at the position \" + this.position;\r\n  }\r\n}\r\n\r\nexport { Snake, Direction };\r\n"]},"metadata":{},"sourceType":"module"}